{
  "Header": {
    "Menu": {
      "GettingStarted": {
        "Name": "Pierwsze kroki",
        "Main": {
          "Description": "W pełni funkcjonalne hooki i narzędzia, które możesz skopiować i użyć w swoich aplikacji. Łatwe. Możliwość dostosowania. Open source.",
          "Link": "/"
        },
        "Introduction": {
          "Name": "Wprowadzenie",
          "Link": "/docs/introduction",
          "Description": "Hooki i narzędzia wielokrotnego użytku zbudowane przy użyciu TypeScript i Vitest."
        },
        "Typesafe": {
          "Name": "Bezpieczeństwo",
          "Link": "/docs/typesafe",
          "Description": "Jak kod jest chroniony przed błędami."
        },
        "Quality": {
          "Name": "Jakość",
          "Link": "/docs/quality",
          "Description": "Czysty i sprawdzony kod."
        }
      }
    },
    "Theme": {
      "ToggleTheme": "Zmień motyw",
      "Dark": "Ciemny",
      "Light": "Jasny",
      "System": "Systemowe"
    },
    "Language": {
      "ToggleLanguage": "Zmień język",
      "English": "Angielski",
      "Polish": "Polski"
    }
  },
  "LandingPage": {
    "Section1": {
      "Heading": "<span>Hooki</span>, <span>narzędzia</span>, <span>komponenty</span> oraz <span>animacje</span> do twoich kolejnych wymagających projektów",
      "Subheading": "Doładuj swój projekt kodem wielokrotnego użytku sprawdzonym za pomocą ESLint i Vitest.",
      "GetStarted": "Wprowadzenie"
    },
    "Section2": {
      "Article1": {
        "Heading": "Wszystko w jednym",
        "Description": "React-reuse to biblioteka React.js o otwartym kodzie źródłowym, służąca do przyspieszania projektów. Zawiera wiele przydatnych hooków, narzędzi i komponentów ułatwiających pracę z kodem. Możesz go używać, jak chcesz. Miłej zabawy!"
      },
      "Article2": {
        "Card0": {
          "Heading": "Hooki",
          "Description": "Biblioteka zawiera",
          "Content": "hooków"
        },
        "Card1": {
          "Heading": "Narzędzia",
          "Description": "Biblioteka zawiera",
          "Content": "narzędzi"
        },
        "Card2": {
          "Heading": "Komponenty",
          "Description": "Biblioteka zawiera",
          "Content": "komponenty"
        },
        "Card3": {
          "Heading": "Animacje",
          "Description": "Biblioteka zawiera",
          "Content": "animacje"
        }
      },
      "Button": "Zobacz więcej",
      "CommingSoon": "Wkrótce"
    },
    "Section3": {
      "Heading": "Dlaczego to?",
      "Description": "Nasza biblioteka React.js zawierająca hooki, narzędzia, komponenty oraz animacje została zaprojektowana w celu usprawnienia procesu programowania.",
      "Accordions": {
        "Accordion1": {
          "Title": "Prostota",
          "Content": "Łatwe w użyciu interfejsy API, które redukują schematy i zapewniają czystość kodu."
        },
        "Accordion2": {
          "Title": "Elastyczność",
          "Content": "Modułowa konstrukcja pozwala wybrać tylko to, czego potrzebujesz, dostosowane do Twojego projektu."
        },
        "Accordion3": {
          "Title": "Kierowany przez społeczność",
          "Content": "Wspierane przez najlepsze praktyki i wkład programistów z całego świata."
        },
        "Accordion4": {
          "Title": "Czy mogę to wykorzystać w swoim projekcie?",
          "Content": "Tak. Można go używać bezpłatnie do projektów osobistych i komercyjnych. Nie jest wymagane podanie źródła."
        }
      }
    }
  },
  "Data": {
    "ScrollIntoViewItems": {
      "Entry": "Wprowadzenie",
      "Testing": "Testy Vitest",
      "TypeScript": "TypeScript",
      "Linting": "Lintowanie oraz jakość kodu",
      "Description": "Opis",
      "Code": "Kod",
      "Parameter": "Parametry",
      "API": "API"
    },
    "Docs": {
      "Name": "Pierwsze kroki",
      "Link": "/docs/introduction",
      "Items": {
        "introduction": {
          "Link": "/docs/introduction",
          "Name": "Wprowadzenie",
          "Content": "<h2>Wstęp</h2>Witamy w naszej kompleksowej bibliotece niestandardowych hooków React, funkcji pomocniczych, komponentów i animacji, <bold>stworzonych w celu usprawnienia i ulepszenia Twojego procesu tworzenia aplikacji.</bold> Ta kolekcja narzędzi została opracowana z silnym naciskiem na możliwość ponownego użycia, wydajność i doświadczenie programisty. Niezależnie od tego, czy pracujesz nad złożonym zarządzaniem stanem, obsługą efektów ubocznych, czy upraszczaniem typowych <bold>wzorów interfejsu użytkownika</bold>, nasze hooki i narzędzia pozwolą Ci tworzyć solidne i skalowalne aplikacje z łatwością.<br></br><br></br> Cała nasza biblioteka jest napisana w TypeScript, co zapewnia bezpieczeństwo typów i automatyczne uzupełnianie kodu od razu po instalacji. Każdy hook i funkcja pomocnicza została rygorystycznie przetestowana za pomocą Vitest, co gwarantuje niezawodność i brak błędów w szerokim zakresie przypadków użycia. Przestrzegamy również najlepszych praktyk w zakresie lintingu i stylu kodu, aby utrzymać czysty i łatwy w utrzymaniu kod.<br></br><br></br>W tym dokumencie omówimy trzy kluczowe aspekty, które wyróżniają naszą bibliotekę: kompleksowe podejście do testowania, zalety TypeScript oraz spójne stosowanie zasad lintingu. <h3>Testowanie z Vitest</h3>Jednym z głównych filarów naszej biblioteki jest rygorystyczny proces testowania, który stosujemy do każdego hooka i funkcji pomocniczej, którą rozwijamy. Wykorzystując <bold>Vitest</bold>, szybkie i nowoczesne środowisko testowe zaprojektowane dla TypeScript i JavaScript, zapewniamy, że każda część kodu spełnia najwyższe standardy niezawodności i funkcjonalności. Testowanie nie jest dla nas dodatkiem – to integralna część naszego procesu tworzenia, pozwalająca wykrywać potencjalne problemy na wczesnym etapie i dostarczać narzędzia, na których możesz polegać.<br></br><br></br> Vitest oferuje szybkie sprzężenie zwrotne i bezproblemowo integruje się z TypeScript, co czyni go idealnym narzędziem do naszych potrzeb testowych. Używamy zarówno <bold>testów jednostkowych, jak i testów integracyjnych</bold>, aby obejmować różne aspekty funkcjonalności. Wysoki poziom pokrycia testami zapewnia, że nasza biblioteka pozostaje niezawodna, nawet gdy dodawane są nowe funkcje lub ewoluuje w czasie. Nasze zaangażowanie w rozwój oparty na testach oznacza, że możesz z pełnym zaufaniem integrować nasze hooki w swoim projekcie, wiedząc, że będą działały zgodnie z oczekiwaniami. <h3>Napisane w TypeScript</h3> Cała nasza biblioteka jest napisana w <bold>TypeScript</bold>, potężnym nadzbiorze JavaScript, który wprowadza statyczne typowanie do kodu. TypeScript zapewnia liczne korzyści, takie jak lepsze narzędzia, ulepszona czytelność kodu i wcześniejsze wykrywanie błędów w trakcie tworzenia. Dzięki używaniu TypeScript we wszystkich naszych hookach i funkcjach pomocniczych zapewniamy Ci maksymalne korzyści z procesu tworzenia, w tym ulepszone automatyczne uzupełnianie kodu, bezpieczeństwo typów i bardziej przewidywalne zachowanie.<br></br><br></br> Definicje typów w naszych hookach i funkcjach pomocniczych zapewniają solidne egzekwowanie kontraktów, zapobiegając typowym błędom zanim się pojawią. TypeScript pozwala nam również tworzyć bardziej wyraziste <bold>API</bold>, dzięki czemu programiści łatwiej rozumieją, jak poprawnie używać każdego hooka. Dzięki wnioskowaniu typów programiści często otrzymują sugestie bezpośrednio w IDE, co przyspiesza tworzenie i zmniejsza ryzyko błędów w czasie działania. Dzięki temu nasze narzędzia są zarówno przyjazne dla programistów, jak i bardzo niezawodne w środowiskach produkcyjnych.<h3>Linting i jakość kodu</h3> Utrzymanie <bold>czystej i spójnej bazy kodu</bold> jest jednym z podstawowych założeń naszego procesu tworzenia. Aby to osiągnąć, stosujemy rygorystyczne zasady lintingu i przestrzegamy najlepszych praktyk dotyczących formatowania kodu. Nasza biblioteka jest w pełni lintowana za pomocą ESLint, co zapewnia, że kod jest nie tylko funkcjonalny, ale również czysty, czytelny i łatwy w utrzymaniu. To pomaga zmniejszyć dług technologiczny i ułatwia wprowadzanie zmian w przyszłości.<br></br><br></br>Linting wymusza również spójność we wszystkich hookach i funkcjach pomocniczych, zapewniając, że wszystkie przestrzegają jednolitego stylu kodowania. Dzięki temu programiści mogą łatwiej zrozumieć kod, szybciej wychwytywać potencjalne błędy i zapobiegać wprowadzaniu złych praktyk. Dodatkowo uruchamiamy lintery jako część naszego procesu ciągłej integracji, co oznacza, że każdy fragment kodu jest sprawdzany pod kątem jakości, zanim zostanie scalony z główną bazą kodu.<separator></separator>Ta biblioteka oferuje starannie opracowany zestaw narzędzi do nowoczesnego tworzenia aplikacji React. Dzięki solidnym podstawom w testowaniu, integracji z TypeScript oraz naciskowi na jakość kodu, nasze hooki i funkcje pomocnicze są niezawodne, przyjazne dla programistów i zaprojektowane tak, aby skalowały się wraz z potrzebami Twojego projektu. Niezależnie od tego, czy chcesz usprawnić swoją bazę kodu, czy zwiększyć wydajność swojej aplikacji, ta kolekcja zapewnia rozwiązania, które pozwolą Ci to osiągnąć z pełnym zaufaniem."
        },
        "typesafe": {
          "Link": "/docs/typesafe",
          "Name": "Bezpieczeństwo",
          "Content": "<h2>Testowanie z Vitest</h2> Jednym z głównych filarów naszej biblioteki jest rygorystyczny proces testowania stosowany do każdego hooka i funkcji pomocniczej, które tworzymy. Korzystając z <bold>Vitest</bold>, szybkiego i nowoczesnego frameworka testowego zaprojektowanego dla TypeScript i JavaScript, zapewniamy, że każdy fragment kodu spełnia najwyższe standardy niezawodności i funkcjonalności. Testowanie nie jest dla nas dodatkiem – to integralna część procesu tworzenia, pozwalająca nam wcześnie wykrywać potencjalne problemy i dostarczać narzędzia, na których można polegać. <h3>Wszechstronne testowanie w różnych scenariuszach</h3> Każdy hook i funkcja pomocnicza w naszej bibliotece przechodzi dokładne testy, aby upewnić się, że zachowuje się poprawnie w szerokim zakresie scenariuszy. Obejmuje to: <ul><li><bold>Przypadki brzegowe:</bold> Symulujemy nietypowe lub nieoczekiwane interakcje użytkowników, aby upewnić się, że nasze narzędzia są wystarczająco solidne, by poradzić sobie z nimi w sposób bezproblemowy.</li><li><bold>Codzienne wzorce użycia:</bold> Testując w typowych i praktycznych scenariuszach, zapewniamy, że nasze hooki działają płynnie w codziennych aplikacjach.</li><li><bold>Testy obciążeniowe:</bold> Hooki są oceniane w warunkach dużego obciążenia, takich jak obsługa dużych zbiorów danych lub szybkie zmiany stanu, aby potwierdzić, że utrzymują optymalną wydajność.</li></ul>To skrupulatne podejście gwarantuje, że nasze narzędzia działają zgodnie z oczekiwaniami, niezależnie od tego, jak prosty czy skomplikowany jest Twój przypadek użycia.<h3>Moc Vitest w naszym procesie</h3>Vitest wyróżnia się jako nowoczesny framework testowy, który łączy szybkość, elastyczność i bezproblemową integrację z TypeScript. Jego błyskawiczna pętla informacji zwrotnej pozwala nam szybko iterować, jednocześnie utrzymując pewność co do niezawodności naszego kodu. Ponadto bliskie powiązanie Vitest z nowoczesnym ekosystemem JavaScript oznacza, że integruje się on płynnie z naszym procesem pracy, umożliwiając pisanie testów, które są zarówno efektywne, jak i łatwe w utrzymaniu.<h5>Stosujemy <bold>wielowarstwową strategię testowania</bold>, która obejmuje:</h5><ol> <li><bold>Testy jednostkowe:</bold> Skupiają się na indywidualnych funkcjach lub hookach, aby zweryfikować, że każdy komponent działa zgodnie z przeznaczeniem w izolacji.</li><li><bold>Testy integracyjne:</bold> Zaprojektowane, aby ocenić, jak hooki współdziałają ze sobą i z zewnętrznymi komponentami, zapewniając płynną funkcjonalność w większych systemach.</li></ol>Łącząc te podejścia, osiągamy wysoki poziom pokrycia testami, co pomaga nam utrzymać niezawodność biblioteki, gdy się rozwija i ewoluuje. To zaangażowanie w testowanie gwarantuje, że wszelkie nowe funkcje lub aktualizacje są wprowadzane bez kompromisów dla istniejącej funkcjonalności.<h3>Pewność dzięki podejściu Test-Driven Development</h3>Nasza biblioteka powstaje z silnym naciskiem na test-driven development (TDD). To podejście polega na pisaniu testów przed implementacją samego kodu, co zapewnia, że każda funkcja jest rozwijana z jasnym zrozumieniem jej wymagań i zachowania. Rezultat? Solidna biblioteka, którą możesz z pewnością zintegrować ze swoimi projektami, wiedząc, że każdy hook i funkcja pomocnicza zostały rygorystycznie zweryfikowane pod kątem działania w różnych warunkach.<h2>Tworzone w TypeScript</h2>Cała nasza biblioteka jest rozwijana przy użyciu <bold>TypeScript</bold>, potężnego nadzbioru JavaScript, który wprowadza statyczne typowanie do języka. Wybierając TypeScript jako fundament dla naszych hooków i narzędzi, odblokowujemy bogactwo korzyści, które poprawiają doświadczenie deweloperskie i jakość końcowego produktu.<h3>Zalety TypeScript</h3>TypeScript oferuje wiele funkcji, które są szczególnie cenne przy budowaniu i utrzymywaniu złożonych bibliotek:<ol><li><bold>Bezpieczeństwo typów:</bold> Dzięki statycznemu typowaniu potencjalne błędy są wychwytywane podczas tworzenia, zmniejszając ryzyko problemów w czasie wykonywania w produkcji.</li><li><bold>Zaawansowane narzędzia:</bold> Integracja TypeScript z nowoczesnymi IDE zapewnia solidne funkcje, takie jak autouzupełnianie kodu, dokumentacja inline i inteligentne sugestie refaktoryzacyjne.</li><li><bold>Poprawiona czytelność kodu:</bold> Dzięki jawnie zdefiniowanym typom sprawiamy, że nasze hooki i narzędzia są łatwiejsze do zrozumienia i użycia, zarówno dla Ciebie, jak i Twojego zespołu.</li></ol><h3>Solidne definicje typów dla lepszych API</h3>Definicje typów w naszej bibliotece pełnią rolę kontraktu między naszymi narzędziami a ich użytkownikami. Te definicje jasno określają oczekiwane wejścia i wyjścia każdego hooka, zmniejszając ryzyko błędów i zapewniając, że Twój kod pozostaje przewidywalny i łatwy w utrzymaniu.<h5>Dodatkowo TypeScript pozwala nam tworzyć <bold>wyraziste i intuicyjne API.</bold> Na przykład:</h5><ul><li>Hooki automatycznie wnioskują typy z ich wejść, dzięki czemu nie musisz podawać nadmiarowych adnotacji typów.</li><li>Złożone struktury danych są upraszczane za pomocą jasnych, samodokumentujących się definicji typów.</li></ul><h3>Doświadczenie deweloperskie spotyka niezawodność w produkcji</h3>TypeScript oferuje zaawansowane funkcje, takie jak unie rozróżnialne i generyki, które pozwalają projektować API, które są zarówno potężne, jak i przyjazne dla użytkownika. Te możliwości nie tylko poprawiają <bold>doświadczenie deweloperskie</bold> podczas implementacji, ale także przekładają się na <bold>większą niezawodność</bold> w środowiskach produkcyjnych. Dzięki wczesnemu wykrywaniu błędów i egzekwowaniu ścisłych reguł typowania TypeScript pomaga nam dostarczać narzędzia, które są jednocześnie elastyczne i solidne.<h5>Niezależnie od tego, czy integrujesz nasze hooki z małym projektem, czy dużą aplikacją korporacyjną, połączenie rozwoju opartego na TypeScript i testowania wspieranego przez Vitest zapewnia, że masz bibliotekę, której możesz zaufać, aby spełniała Twoje potrzeby.</h5>"
        },
        "quality": {
          "Link": "/docs/quality",
          "Name": "Jakość",
          "Content": "<h2>Linting i Jakość Kodu</h2>Utrzymanie czystego, spójnego i wysokiej jakości kodu jest podstawową zasadą w naszym procesie deweloperskim. Dobrze utrzymana baza kodu sprzyja współpracy, skalowalności i łatwości zarządzania w miarę rozwoju projektu. Poniżej przedstawiamy, jak osiągamy i egzekwujemy te standardy.<h3>Dlaczego Jakość Kodu Ma Znaczenie</h3><ul><li><bold>Czytelność:</bold> Czysty kod jest łatwiejszy do zrozumienia i modyfikacji.</li><li><bold>Łatwość utrzymania:</bold> Dobrze zorganizowana baza kodu redukuje dług techniczny i wspiera długoterminowy rozwój.</li><li><bold>Współpraca:</bold> Spójny kod ułatwia pracę zespołów i współpracy z innymi deweloperami.</li></ul><h3>Jak Egzekwujemy Jakość Kodu</h3><ol><li><bold>Używanie ESLint do Lintingu</bold><br></br>Opieramy się na <bold>ESLint</bold>, potężnym narzędziu do egzekwowania standardów kodowania. Zapewnia ono, że:<ul><li>Kod przestrzega wcześniej określonych zasad i najlepszych praktyk.</li><li>Problemy są wykrywane wcześnie w cyklu deweloperskim.</li><li>Biblioteka pozostaje czysta, czytelna i łatwa do utrzymania.</li></ul></li><li><bold>Przyjęcie Spójnego Stylu Kodowania</bold><br></br>Spójność jest kluczem. Aby zapewnić jednolity wygląd i strukturę w całej bazie kodu:<ul><li>Wszystkie haki i narzędzia przestrzegają tych samych konwencji kodowania.</li><li>Deweloperzy mogą łatwo nawigować i rozumieć strukturę oraz logikę kodu.</li></ul></li><li><bold>Automatyzacja Sprawdzania Jakości w CI</bold><br></br>Nasza pipeline <bold>Continuous Integration (CI)</bold> zawiera automatyczne sprawdzanie lintingowe:<ul><li>Każda zmiana kodu jest analizowana pod kątem jakości przed połączeniem.</li><li>Potencjalne problemy są wykrywane wcześniej, zmniejszając ryzyko wprowadzenia błędów.</li></ul></li></ol><h2>Korzyści z Lintingu</h2><ul><li><bold>Zapobieganie Błędom:</bold> Identyfikuje problemy, takie jak błędy składniowe czy złe praktyki.</li><li><bold>Ulepszona Współpraca:</bold> Standaryzowany kod jest łatwiejszy do współpracy dla zespołów i współautorów.</li><li><bold>Przygotowanie na Przyszłość:</bold> Czysty, spójny kod jest łatwiejszy do dostosowania do przyszłych aktualizacji i rozszerzeń.</li></ul> Priorytetowe traktowanie lintingu i jakości kodu zapewnia, że nasza biblioteka pozostaje solidna, niezawodna i łatwa w użyciu. To zaangażowanie buduje silną podstawę dla przyszłego rozwoju i tworzy środowisko, w którym deweloperzy mogą się rozwijać."
        }
      }
    },
    "Hooks": {
      "Name": "Hooks",
      "Link": "/docs/hooks",
      "SectionItems": {
        "Code": {
          "Hook": "Hook",
          "Usage": "Zastosowanie"
        },
        "Parameter": {
          "Name": "Parametry",
          "Content": "Ten hook akceptuje następujące argumenty:"
        },
        "Footer": {
          "Previous": "Poprzedni",
          "Next": "Następny"
        }
      },
      "Items": {
        "useclipboard": {
          "Link": "/docs/hooks/useclipboard",
          "Name": "useClipboard",
          "Content": {
            "Description": "useClipboard to niestandardowy hook React, który zapewnia prosty interfejs do kopiowania tekstu do schowka użytkownika za pomocą API Clipboard. Obsługuje stan powodzenia i błędów oraz zawiera funkcję resetowania w celu wyczyszczenia bieżącego stanu. Ten hook upraszcza kopiowanie tekstu do schowka i zapewnia informację zwrotną, czy operacja się powiodła.",
            "Parameters": "",
            "API": "copyToClipboard(text: string): void: Pobiera ciąg znaków i próbuje skopiować go do schowka. Jeśli się powiedzie, aktualizuje wartość isCopied do wartości true; w przypadku niepowodzenia wyświetla komunikat o błędzie. & isCopied: boolean: Flaga logiczna wskazująca, czy tekst został pomyślnie skopiowany do schowka. & error: string | null: Jeśli kopiowanie do schowka nie powiedzie się, ten ciąg zawiera komunikat o błędzie. Jest null, jeśli nie ma błędu. & reset: void: Resetuje stany isCopied i error do ich wartości początkowych. Przydatne, jeśli chcesz zresetować hook po udanej lub nieudanej akcji schowka."
          },
          "CreateAt": "2024-10-17"
        },
        "usechatgpt": {
          "Link": "/docs/hooks/usechatgpt",
          "Name": "useChatGPT",
          "Content": {
            "Description": "Hook useChatGPT to niestandardowy hook React, który umożliwia interakcję z API ChatGPT. Zarządza procesem wprowadzania danych przez użytkownika do API, obsługą stanów ładowania i błędów oraz przechowywaniem odpowiedzi API. Można go łatwo zintegrować z dowolnym komponentem React, aby włączyć funkcje chatbota.",
            "Parameters": "apiKey (string): Klucz API używany do uwierzytelniania żądań do API OpenAI.",
            "API": "sendMessage(message: string): Promise'<'void'>': Funkcja, która przyjmuje wiadomość w postaci tekstu, wysyła ją do API ChatGPT i aktualizuje stan odpowiedzi. & response: string | null: Odpowiedź z API ChatGPT, lub null, jeśli brak jest dostępnej odpowiedzi. & isLoading: boolean: Wartość boolean wskazująca, czy żądanie do API ChatGPT jest w trakcie realizacji. & error: string | null: Komunikat o błędzie, jeśli wystąpił błąd podczas żądania do API, lub null, jeśli błędu nie było."
          },
          "CreateAt": "2024-10-17"
        },
        "usepromiseall": {
          "Link": "/docs/hooks/usepromiseall",
          "Name": "usePromiseAll",
          "Content": {
            "Description": "Hook usePromiseAll służy do równoległego wykonywania wielu obietnic (promises), dostarczając prosty sposób śledzenia stanu ładowania, sukcesu i błędów. Po rozwiązaniu wszystkich obietnic (lub ich odrzuceniu) hook zwraca wyniki lub błąd, a także stan ładowania.",
            "Parameters": "promises: Promise'<'T'>'[]: Tablica obietnic do wykonania równocześnie.",
            "API": "results: T[] | null: Rozwiązane wartości wszystkich obietnic lub null w przypadku, gdy trwa ładowanie. & error: Error | null: Każdy napotkany błąd w trakcie wykonywania obietnic, lub null w przypadku braku błędów. & isLoading: boolean: Wartość logiczna reprezentująca stan ładowania (true podczas oczekiwania na obietnice, false, gdy wszystkie zostaną rozwiązane lub jedna zostanie odrzucona)."
          },
          "CreateAt": "2024-10-17"
        },
        "usehover": {
          "Link": "/docs/hooks/usehover",
          "Name": "useHover",
          "Content": {
            "Description": "Hook useHover wykrywa, kiedy element jest najechany myszką. Zwraca stan hovered w postaci wartości boolean, która informuje, czy myszka aktualnie znajduje się nad elementem, oraz ref, który należy przypisać do elementu, który chcemy śledzić.",
            "Parameters": "",
            "API": "hovered: boolean: true jeśli element jest aktualnie najechany myszką, w przeciwnym wypadku false. & ref: React.RefObject'<'T'>': ref, który należy przypisać do śledzonego elementu, aby wykrywać stan najechania."
          },
          "CreateAt": "2024-10-17"
        },
        "useclickoutside": {
          "Link": "/docs/hooks/useclickoutside",
          "Name": "useClickOutside",
          "Content": {
            "Description": "Niestandardowy hook, który wywołuje funkcję zwrotną, gdy kliknięcie zostanie wykryte poza elementem referencyjnym.",
            "Parameters": "ref (RefObject'<'HTMLElement'>'): Obiekt ref React wskazujący na element HTML, który ma być monitorowany pod kątem kliknięć zewnętrznych. & callback(): void: Funkcja, która ma być wywołana, gdy kliknięcie poza referencyjnym elementem zostanie wykryte.",
            "API": ""
          },
          "CreateAt": "2024-10-17"
        },
        "usedebounce": {
          "Link": "/docs/hooks/usedebounce",
          "Name": "useDebounce",
          "Content": {
            "Description": "Hook useDebounce opóźnia aktualizację wartości do momentu, gdy minie określony czas od ostatniej zmiany wartości. Jest to przydatne w scenariuszach takich jak filtrowanie danych w czasie rzeczywistym lub zapobieganie wielokrotnym wywołaniom API na szybko zmieniające się dane.",
            "Parameters": "value: T: Aktualna wartość do debouncingu. Może być dowolnego typu (T). & delay: number: Opóźnienie debouncingu w milisekundach.",
            "API": "debouncedValue: T: Zdebouncowana wartość, która aktualizuje się po określonym czasie."
          },
          "CreateAt": "2024-10-17"
        },
        "usesort": {
          "Link": "/docs/hooks/usesort",
          "Name": "useSort",
          "Content": {
            "Description": "Hook useSort pomaga w łatwym sortowaniu list danych, udostępniając posortowaną wersję listy na podstawie podanej funkcji sortowania. Umożliwia również przełączanie między rosnącym i malejącym porządkiem.",
            "Parameters": "items: T[]: Lista elementów do posortowania. & sortFn: (a: T, b: T): number: Funkcja sortowania, która określa, jak porównać dwa elementy listy. Powinna zwrócić liczbę ujemną, jeśli a jest przed b, liczbę dodatnią, jeśli a jest po b, oraz 0, jeśli są równe. & initialOrder:? 'asc' | 'desc': Początkowy porządek sortowania. Domyślnie 'asc' (rosnąco).",
            "API": "sortedItems: T[]: Posortowana wersja podanej listy. & order: 'asc' | 'desc': Aktualny porządek sortowania. & toggleOrder(): void: Funkcja do przełączania między rosnącym ('asc') a malejącym ('desc') porządkiem."
          },
          "CreateAt": "2024-10-17"
        },
        "usemediaquery": {
          "Link": "/docs/hooks/usemediaquery",
          "Name": "useMediaQuery",
          "Content": {
            "Description": "Hook useMediaQuery pozwala na monitorowanie zmian zapytań medialnych w komponencie React. Umożliwia to dostosowanie zachowania komponentu w zależności od rozmiaru okna przeglądarki lub innych cech mediów, takich jak orientacja urządzenia czy rozdzielczość.",
            "Parameters": "query: string:  Łańcuch znaków reprezentujący zapytanie medialne, które chcesz monitorować.",
            "API": "isMobile: boolean: true, jeśli zapytanie medialne pasuje do obecnego widoku, w przeciwnym razie false."
          },
          "CreateAt": "2024-10-17"
        },
        "usekeyboardshortcup": {
          "Link": "/docs/hooks/usekeyboardshortcup",
          "Name": "useKeyboardShortcup",
          "Content": {
            "Description": "Hook useKeyboardShortcut nasłuchuje określonych kombinacji klawiszy (np. 'Ctrl+S' lub 'Alt+Shift+P') i wywołuje funkcję zwrotną, gdy taka kombinacja zostanie naciśnięta. To przydatne do implementowania skrótów klawiaturowych, szybkich akcji lub niestandardowej nawigacji opartej na klawiszach w aplikacji.",
            "Parameters": "keys: string[]: Tablica klawiszy (np. ['Control', 'S'] lub ['Alt', 'Shift', 'P']), które reprezentują kombinację klawiszy. & callback(): void: Funkcja, która zostanie wywołana, gdy kombinacja klawiszy zostanie naciśnięta. & element:? HTMLElement | Window: Element DOM, do którego przypięty jest nasłuchiwacz. Domyślnie window.",
            "API": ""
          },
          "CreateAt": "2024-10-17"
        },
        "usecounter": {
          "Link": "/docs/hooks/usecounter",
          "Name": "useCounter",
          "Content": {
            "Description": "Hook useCounter dostarcza prostą funkcjonalność zarządzania licznikami, taką jak inkrementacja, dekrementacja, resetowanie oraz ustawianie konkretnej wartości.",
            "Parameters": "initialValue?: number: Początkowa wartość licznika. Domyślnie 0.",
            "API": "count: number: Aktualna wartość licznika. & increment(): void: Zwiększa licznik o 1. & decrement(): void: Zmniejsza licznik o 1. & reset(): void: Resetuje licznik do wartości początkowej initialValue. & set(value: number): void: Ustawia licznik na podaną wartość."
          },
          "CreateAt": "2024-10-17"
        },
        "uselocalstorage": {
          "Link": "/docs/hooks/uselocalstorage",
          "Name": "useLocalStorage",
          "Content": {
            "Description": "Hook useLocalStorage służy do przechowywania i pobierania wartości z localStorage w komponencie React. Działa podobnie do hooka useState, ale przechowuje wartość również po odświeżeniu lub ponownym otwarciu strony. Hook automatycznie synchronizuje stan z localStorage i zapewnia, że wartość jest zawsze aktualna.",
            "Parameters": "key: string: Klucz, pod którym wartość jest przechowywana w localStorage. & initialValue: string: Początkowa wartość do przechowania. Może to być wartość lub funkcja zwracająca wartość.",
            "API": "[storedValue, setValue]: array: storedValue to aktualna wartość z localStorage, a setValue to funkcja do aktualizacji wartości."
          },
          "CreateAt": "2024-10-17"
        },
        "usesearch": {
          "Link": "/docs/hooks/usesearch",
          "Name": "useSearch",
          "Content": {
            "Description": "Hook useSearch umożliwia łatwe zarządzanie zapytaniami wyszukiwania i wynikami. Filtruje listę elementów na podstawie podanego zapytania i funkcji filtrowania. Hook obsługuje debouncing, aby zoptymalizować wydajność poprzez unikanie nadmiernego filtrowania podczas szybkiego wprowadzania danych.",
            "Parameters": "items: T[]: Lista elementów do przeszukania. & filterFn: (item: T, query: string): boolean: Funkcja określająca, jak filtrować elementy na podstawie zapytania wyszukiwania. & debounceDelay:? number: Opóźnienie (w milisekundach) dla debouncingu wyszukiwania. Domyślnie 300ms.",
            "API": "query: string: Aktualny ciąg zapytania wyszukiwania. & setQuery: (query: string): void: Funkcja do aktualizacji zapytania wyszukiwania. & filteredItems: T[]: Lista przefiltrowanych elementów na podstawie zapytania wyszukiwania. & isSearching: boolean: Wartość logiczna wskazująca, czy hook aktywnie wyszukuje (z debouncingiem)."
          },
          "CreateAt": "2024-10-17"
        },
        "useinterval": {
          "Link": "/docs/hooks/useinterval",
          "Name": "useInterval",
          "Content": {
            "Description": "useInterval to niestandardowy hook React, który umożliwia ustawianie powtarzających się działań (takich jak regularne odpytywanie API lub animowanie) w określonych odstępach czasowych w komponencie React. Automatycznie zarządza ustawianiem i usuwaniem interwału, aby uniknąć wycieków pamięci lub pozostawienia nieaktualnych interwałów, gdy komponent się zaktualizuje lub odmontuje.",
            "Parameters": "callback(): void: Funkcja, którą chcesz wykonywać w regularnych odstępach czasu. & delay: number: Opóźnienie w milisekundach pomiędzy kolejnymi wykonaniami. Jeśli opóźnienie wynosi null, interwał zostanie wstrzymany.",
            "API": ""
          },
          "CreateAt": "2024-10-17"
        },
        "usescrollintoview": {
          "Link": "/docs/hooks/usescrollintoview",
          "Name": "useScrollIntoView",
          "Content": {
            "Description": "Hook useScrollIntoView został zaprojektowany do przewijania elementu (reprezentowanego przez ref) do widoku, z możliwością dostosowania zachowania przewijania. Udostępnia funkcję zwrotną, która uruchamia akcję przewijania i pozwala na określenie sposobu przewijania (auto lub smooth) oraz pozycjonowania elementu po przewinięciu (opcje jak start, center, end lub nearest zarówno dla osi pionowej, jak i poziomej).",
            "Parameters": "ref: React.RefObject'<'HTMLElement'>': eferencja do elementu, który ma zostać przewinięty do widoku. & behavior:? 'auto' | 'smooth': Sposób przewijania. Domyślnie 'smooth'. & block:? 'start' | 'center' | 'end' | 'nearest': Pionowe wyrównanie elementu po przewinięciu. Domyślnie 'start'. & inline?: 'start' | 'center' | 'end' | 'nearest': Poziome wyrównanie elementu po przewinięciu. Domyślnie 'nearest'.",
            "API": "scrollToElement(): void: Funkcję zwrotną, która po wywołaniu przewija referencjonowany element do widoku."
          },
          "CreateAt": "2024-10-17"
        }
      }
    },
    "Utilities": {
      "Name": "Narzędzia",
      "Link": "/docs/utilities",
      "SectionItems": {
        "Code": {
          "Hook": "Hook",
          "Usage": "Zastosowanie"
        },
        "Parameter": {
          "Name": "Parametry",
          "Content": "Ten hook akceptuje następujące argumenty:"
        },
        "Footer": {
          "Previous": "Poprzedni",
          "Next": "Następny"
        }
      },
      "Items": {
        "show": {
          "Link": "/docs/utilities/show",
          "Name": "<Show />",
          "Content": {
            "Description": "Komponent Show w React umożliwia warunkowe renderowanie elementów potomnych na podstawie określonych warunków. Działa poprzez użycie dwóch podkomponentów: Show.When i Show.Else. Komponent Show.When renderuje swoje dzieci, jeśli właściwość isTrue ma wartość true, a Show.Else jest renderowany, gdy żaden warunek nie został spełniony. Ten komponent upraszcza logikę warunkową, wbudowując ją w JSX.",
            "Parameters": "",
            "API": "isTrue?: boolean: Określa, czy element children powinien zostać wyrenderowane. Jeśli wartość jest true, element zostanie wyrenderowany."
          },
          "CreateAt": "2024-10-17"
        },
        "each": {
          "Link": "/docs/utilities/each",
          "Name": "<Each />",
          "Content": {
            "Description": "Komponent Each to funkcja narzędziowa, która iteruje po tablicy (of) i renderuje każdy element za pomocą dostarczonej funkcji render. Funkcja render otrzymuje dwa argumenty: aktualny element (item) oraz jego indeks (index). Zwraca ona element JSX dla każdego elementu tablicy. Ta funkcja upraszcza proces renderowania elementów z tablic, oferując wielokrotnego użytku i konfigurowalne rozwiązanie.",
            "Parameters": "",
            "API": "render(item: any, index: number): JSX.Element: Wymagana funkcja, która definiuje, jak renderować każdy element tablicy. Przyjmuje dwa argumenty (item - Aktualny element z tablicy, index - Indeks aktualnego elementu). & of: any[]: Wymagana tablica elementów, po której będzie iterować funkcja. Funkcja render jest wywoływana dla każdego elementu tej tablicy."
          },
          "CreateAt": "2024-10-17"
        },
        "delay": {
          "Link": "/docs/utilities/delay",
          "Name": "<Delay />",
          "Content": {
            "Description": "Komponent Delay to narzędzie, które renderuje swoje dzieci po określonym opóźnieniu. Jest przydatny, gdy chcesz opóźnić renderowanie określonych komponentów ze względów UX lub wydajności. Komponent akceptuje właściwość ms, która określa opóźnienie w milisekundach przed wyrenderowaniem dzieci. W czasie opóźnienia komponent może wyświetlić wskaźnik ładowania lub nic.",
            "Parameters": "",
            "API": "ms: number: Opóźnienie w milisekundach przed wyrenderowaniem dzieci."
          },
          "CreateAt": "2024-10-17"
        }
      }
    },
    "Components": {
      "Name": "Komponenty"
    },
    "Animations": {
      "Name": "Animacje"
    }
  },
  "New": "Nowość",
  "OnThisPage": "Na stronie",
  "SearchBar": {
    "ButtonSearchLg": "Szukaj w dokumentacji...",
    "ButtonSearchMd": "Szukaj...",
    "InputSearch": "Zacznij szukać",
    "NoResults": "Brak wyników."
  }
}
